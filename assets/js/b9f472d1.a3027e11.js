"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[193],{60027:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates a new Mutex object.","params":[],"returns":[{"desc":"","lua_type":"Mutex"}],"function_type":"static","source":{"line":52,"path":"src/Mutex/init.lua"}},{"name":"Lock","desc":"Locks the mutex. If the mutex is already locked, the\\ncurrent thread will be added to the queue and suspended\\nuntil the lock is released.","params":[],"returns":[],"function_type":"method","source":{"line":65,"path":"src/Mutex/init.lua"}},{"name":"Unlock","desc":"Unlocks the mutex. If there are threads waiting in the queue,\\nthe next thread will be resumed and granted the lock.\\nIf the mutex is not locked or there are no waiting threads,\\nan error will propagate.","params":[],"returns":[],"function_type":"method","source":{"line":83,"path":"src/Mutex/init.lua"}}],"properties":[],"types":[],"name":"Mutex","desc":"A mutex provides a mutual exclusion synchronization mechanism for controlling\\naccess to shared resources. It ensures that only one thread or process can\\nacquire the lock at a time, preventing concurrent access and potential conflicts.\\n\\nExample usage:\\n```lua\\nlocal Mutex = require(path.to.Mutex)\\n\\nlocal myMutex = Mutex.new()\\n\\n-- Thread 1\\ncoroutine.wrap(function()\\n    print(\\"Thread 1: Attempting to lock the mutex\\")\\n    myMutex:Lock()\\n    print(\\"Thread 1: Mutex locked\\")\\n\\n    -- Do some critical section operations\\n\\n    print(\\"Thread 1: Unlocking the mutex\\")\\n    myMutex:Unlock()\\n    print(\\"Thread 1: Mutex unlocked\\")\\nend)()\\n\\n-- Thread 2\\ncoroutine.wrap(function()\\n    print(\\"Thread 2: Attempting to lock the mutex\\")\\n    myMutex:Lock()\\n    print(\\"Thread 2: Mutex locked\\")\\n\\n    -- Do some critical section operations\\n\\n    print(\\"Thread 2: Unlocking the mutex\\")\\n    myMutex:Unlock()\\n    print(\\"Thread 2: Mutex unlocked\\")\\nend)()\\n```","source":{"line":45,"path":"src/Mutex/init.lua"}}')}}]);